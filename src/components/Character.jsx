/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/character.glb -o src/components/Character.jsx -r public
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useEffect, useRef } from "react";
import * as THREE from "three";

export function Character({ animation, ...props }) {
  const group = useRef();
  const { nodes, materials, animations, scene } = useGLTF(
    "/models/character.glb"
  );
  
  const { actions, mixer } = useAnimations(animations, group);
  const previousAction = useRef(null);
  
  // Log available animations
  useEffect(() => {
    if (animations.length > 0) {
      console.log("Available animations:", animations.map((a) => a.name));
    }
  }, [animations]);

  // Update animation mixer on each frame
  useFrame((state, delta) => {
    if (mixer) {
      mixer.update(delta);
    }
  });

  // Handle animation playback
  useEffect(() => {
    if (!actions || !animation) return;

    // Find animation with case-insensitive matching
    let action = actions[animation];
    
    // Try exact match first
    if (!action) {
      // Try case-insensitive match
      const actionKey = Object.keys(actions).find(
        (key) => key.toLowerCase() === animation.toLowerCase()
      );
      if (actionKey) {
        action = actions[actionKey];
      }
    }
    
    // Try common variations if still not found
    if (!action) {
      const variations = [
        animation.toLowerCase(),
        animation.charAt(0).toUpperCase() + animation.slice(1).toLowerCase(),
        animation.toUpperCase(),
      ];
      for (const variant of variations) {
        if (actions[variant]) {
          action = actions[variant];
          break;
        }
      }
    }

    if (action) {
      // Fade out previous action
      if (previousAction.current && previousAction.current !== action) {
        previousAction.current.fadeOut(0.2);
      }
      
      // Play new action
      action
        .reset()
        .fadeIn(0.2)
        .setLoop(THREE.LoopRepeat)
        .play();
      
      previousAction.current = action;
      console.log("Playing animation:", animation, "->", action.getClip().name);
    } else {
      console.warn(`Animation "${animation}" not found. Available:`, Object.keys(actions));
      // Try to play the first available animation as fallback
      const firstAction = Object.values(actions).find(a => a);
      if (firstAction && firstAction !== previousAction.current) {
        if (previousAction.current) {
          previousAction.current.fadeOut(0.2);
        }
        firstAction.reset().fadeIn(0.2).setLoop(THREE.LoopRepeat).play();
        previousAction.current = firstAction;
        console.log("Playing fallback animation:", firstAction.getClip().name);
      }
    }

    return () => {
      if (action) {
        action.fadeOut(0.2);
      }
    };
  }, [actions, animation]);
  return (
    <group ref={group} {...props} dispose={null}>
      {/* prefer rendering the original scene if present */}
      {scene ? (
        <primitive object={scene} />
      ) : (
        <group name="Scene">
          <group name="fall_guys">
            {nodes?._rootJoint && <primitive object={nodes._rootJoint} />}
            {/* render skinned meshes if material exists; otherwise render a visible debug mesh */}
            {nodes?.body?.geometry &&
              (materials?.Material ? (
                <skinnedMesh
                  name="body"
                  geometry={nodes.body.geometry}
                  material={materials.Material}
                  skeleton={nodes.body.skeleton}
                  castShadow
                  receiveShadow
                />
              ) : (
                <mesh geometry={nodes.body.geometry} castShadow receiveShadow>
                  <meshStandardMaterial
                    color={"#ff7f50"}
                    skinning={!!nodes.body.skeleton}
                  />
                </mesh>
              ))}
            {nodes?.eye?.geometry &&
              (materials?.Material ? (
                <skinnedMesh
                  name="eye"
                  geometry={nodes.eye.geometry}
                  material={materials.Material}
                  skeleton={nodes.eye.skeleton}
                  castShadow
                  receiveShadow
                />
              ) : (
                <mesh geometry={nodes.eye.geometry} castShadow receiveShadow>
                  <meshStandardMaterial color={"#ffffff"} />
                </mesh>
              ))}
            {nodes?.["hand-"]?.geometry &&
              (materials?.Material ? (
                <skinnedMesh
                  name="hand-"
                  geometry={nodes["hand-"].geometry}
                  material={materials.Material}
                  skeleton={nodes["hand-"].skeleton}
                  castShadow
                  receiveShadow
                />
              ) : (
                <mesh
                  geometry={nodes["hand-"].geometry}
                  castShadow
                  receiveShadow
                >
                  <meshStandardMaterial color={"#cccccc"} />
                </mesh>
              ))}
            {nodes?.leg?.geometry &&
              (materials?.Material ? (
                <skinnedMesh
                  name="leg"
                  geometry={nodes.leg.geometry}
                  material={materials.Material}
                  skeleton={nodes.leg.skeleton}
                  castShadow
                  receiveShadow
                />
              ) : (
                <mesh geometry={nodes.leg.geometry} castShadow receiveShadow>
                  <meshStandardMaterial color={"#999999"} />
                </mesh>
              ))}
          </group>
        </group>
      )}
    </group>
  );
}

useGLTF.preload("/models/character.glb");
